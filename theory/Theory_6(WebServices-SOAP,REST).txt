1. Web Services

   Уеб услугите са всеки софтуер, приложение или cloud технлогия, които предоставят стандартизиран начин за комуникация с тях посредством интернет, използвайки най-често HTTP/HTTPS.
   Форматът на съобщенията, които се обменят между уеб услугите е обикновено стандартизиран : XML, JSON.
   В контекста на уеб услуги имаме две страни на комуникацията :
                                   -> консуматор - това е клиента / активната страна
                                   -> прозиводител (producer) - слушащата за заявки страна (сървър)
   
   Много важно е да се отбележи,че когато говорим за уеб услуги комуникацията е machine to machine и не става въпрос за присъствие на UI. С оглед на това важни изисквания към уеб услугите е да имат :

                      -> добре специфициран договор, чрез който да се разбира в детайли за услугата : как се извиква, какви входни параметри приема и тяхното значение, структурата и значението на резултата
                    
                      -> вид на данните, който е стандартен и лесен за обработка : JSON, XML

   Има два главни подхода при дефинирането на една уеб услуга  :

        -> Contract first : по-добре се прилага при SOAP уеб услугите, където първо договорът (contract) се описва в отделен WSDL(Web Service Description Language) файл. След като вече има описана уеб услугата
                            програмистите могат да напишат ръчно консуматор за тази уеб услуга във вид на класове или пък да използват инструменти, които правят това автоматично.
                            При REST се наблюдава подобен механизъм, като там може да се използва OpenAPI (JSON структура) за автоматично генераиране на документ, който е във формат четим от хората.

        -> Code first : По-често се използва от producer страната. Програмистът имплементира бизнес изискванията във вид на код и някакъв допълнителен framework генерира договора (contract) или документация четима от човек.
                        Договорът се споделя с дугите програмисти, които искат да консумрат съответната уеб услуга.


   Когато създаваме една уеб услуга трябва да сме наясно, че тя ще еволюира и може да се наложи промяна във формата на данните, които връщаме : премахване на някои полета, добавяне на нови, преименуване и т.н. Как обаче това
   да се направи без да предизвикаме необходимостта от моментални промени в консумиращите уеб услугата, които са конфигурирани да получават данните в стария им вид и ако те се променят се налага нова конфигурация на консуматорите,
   което естествено коства време (down-time). Затова продуциращия уеб-услугата трябва да поддържа възможност за едновременно предлагане на различни версии на продуцираните данни и текущите консуматори да могат да се преконфигурират към
   новия вид на данните, когато сметнат, че за тях е подходящото време, а не незабавно (както би станало, ако нямаме версониране на данните).
    От гледна точка на REST имаме няколко варианта за поддържане на различни версии : 
  
                                                   -> поддържане на версии чрез URL : Тук клиентите изрично посочват в url-a коя версия на уеб услугата искат и така ще имаме методи в контролерите, които ще обслужват заявките спрямо
                                                                                      версиите. Пример:

                                                                                                http://mydomain.com/service/v1
                                                                                                http://mydomain.com/service/v2
                                                                                               

                                                   -> поддържане на версии чрез къстъм хедър в самата http заявка : Клиентът слага при заявката къстъм хедър за съответната версия, а на ниво контролер в хендлър методите може да
                                                      се провери за наличието на съответен хедър. Пример :  @GetMapping(value="/person/header", headers="X-API-Version=2")  


                                                   -> поддържане на версия чрез използването на Accept хедъра на  http заявката : В хендлър метода ще трябва да укажем коакъв туп данни се продуцират. Приемр:
                                                                                                                                  @GetMapping(value="/person/produces", produces="application/vnd.company.app-v1+json")  



   От гледана точка на SOAP вариантите за версониране може да се постигат чре прилагане на шаблони (паттерн-и) https://www.oracle.com/technical-resources/articles/web-services-versioning.html: 

            	-> Consumer Binding Pattern
  
                -> Layer of Indirection Pattern

                -> Adapter Pattern

2. Tolerant Reader Pattern от страна на консуматора


   Be conservative in what you do, be liberal in what you accept from others! (Postel's Law which first was stated about TCP/IP but applies for higher-level app concepts also)

   На база на горния съвет Martin Flower формулира Tolerаnt Reader като service design pattern. Шаблонът се фокусира върху колаборацията между сървисите и договорите (contracts), които споделят
   помежду си относно техните API-та (точки за достъп до тяхната функционалност). Еволюирането на тези апита не трябва да прави компромис със съшествуващите техни консуматори, затова трябва да се
   подсигурява обратна съвместимост. За постигането на това обаче не само продуцентите на апитата трябва да гледат да не "счупят" функциналност на клиентите, но и самите клиента да са такива, че да
   имат толерантност относно консумираните данни.

   Съществуват различни аспекти, чрез които може да се доближим до изпълнението на tolerant reader pattern : 

         -> От клиентска страна да се чете само това, което го интересува, новодобавената информация да се игнорира. Използват се DTO обекти.
 
         -> Използване на HATEOAS

2. WSDL (Web Service Description Language)

   XML базиран стандарт за описание на една уеб услуга. Чрез него клиентите, които евентуално ще ползват услугата придобиват яснота как да се свържат към нея и с какви функционалности разполага.
   Един WSDL документ също казва на клиента какви типове SOAP съобщения се приемат и връщат от уеб услугата.


   2.1 Структура на един WSDL документ

       -> definition
          -> types
             -> messages
          -> porttype
             -> opeartion
               -> input
               -> output

        -> binding

        -> service
           -> port


	2.1.1 <types> : В този елемент се дефинират всички типове данни, които се обменят между клиента и уеб услугата. Като обикновено става въпрос за съставни типове (данните от един клас)

        2.1.2 <message> :  Използва се за дефинирането на съобщението, което се изпраща между клиентското приложение и уеб сървъра. Дефинира се типа на параметъра, който ще бъде в съобщението или
                           ще излезе от него.

        2.1.3 <portType> : Използва се за капсулиране на входните и изходните съобщения в една логическа операция. Например имаме операция, която се казва getEmployee. Тя комбинира входното съобщение,
                           което се дава от клиента (например EmployeeID) и изходното съобщение, което се връща от услугата (например EmployeeName). 

        2.1.4 <binding> : Използва се за обвързването на дадена операция към конретен <portType>. Разбирай URL, чрез който може да се достъпи услугата се обвързва с входните и изходните съобщения на самата услуга.

        2.1.5 <service> : посочва url-a на услугата

3. SOAP (Simple Object Access Protocol)

  Идеята е уеб услугите да могат да се стартират от и да обменят информация с други уеб улуги използвайки стандартизирани съобщения в XML формат, които се предават посредством HTTP протокола. 
  Характерното за SOAP e, че е езиково и платофoрмено независим, т.е Java базирани системи, .NET или PHP могат да комуникират без много усложнения.


  3.1 Структура на SOAP съобщенията

      -> SOAP Envelopе Element : Този елемент капсулира всички останали други, т.е той е най-външният. Чрез него се обозначава началото и края на едно SOAP съобщение.

         -> SOAP Hedaer : Съдържа хедърна информация като креденшъли за автентикация, дефиниции на сложни типове (класове), които се използват по-надлоу в съобщението

         -> SOAP Body : Елементът, в който се намира същинските данни обменяни между  уеб услугите. Съдържа извиквания на конкретни методи и параметрите към тях, или резултати от изпълнени такива методи.


   3.2 JAX-WS (Java API for XML-Based Web Services)

       Представлява спецификация, която указва как трябва да бъдат създавани уеб услугите обикновено базирани на SOAP. Или по-конкретно как да създадем WSDL файл от съществуващ вече Java Service клас (code first) или
       обратно от създаден WSDL файл да генерираме Java service класове.

       До JDK 8 има вградена имплементация на JAX-WS, която се води RI (reference implementation, т.е препоръчваната имплементация). Тази имплементация обаче съдържа само базови неща и ако искаме да добавяме нещо по-сложно
       като WS Security, ни трябва някоя алтернативна и по-обхватна имплементация като Apache CXF. CXF също поддържа REST 


4. REST (according to PayPal guidelines and based on Roy Fielding dissertation - https://github.com/paypal/api-standards/blob/master/api-style-guide.md)



   4.1 Приниципите за дизайн на един сървис (услуга)

       -> Loose coupling : Предоставящите дадената улуга и тези, които я консумират не трябва да бъдат тясно обврзани. Прилагането на този принцип води до това, че сървисите могат да еволюират независмо от консуматорите
                           и няма да нарушават тяхното изпълнеине, ако това се случи.


       -> Encapulation : Един сървис част от домейна може да достъпва данни и функционалности, които не притежава, като използва други сървси.

       -> Stability : Вкараването на нова функционалност не трябва да нарушава работата на текущите потребители на услугата

       -> Reusable :  Сървисите трябва да се разработват, так че да позволяват използването им от различни консуматори, в разнообразни контексти.

       -> Contract-based : Този принцип се застъпва за това, че функционалност и данни трябва да бъдат предлагани по стандартизиран начин

       -> Consistency : Услугите трябва да следват общо множество от правила, стил на взаимодействие, лексика и споделени типове. По този начин консуматорите ще могат лесно и бързо да се приспособят към това как да се 
                        използва предлаганата услуга

       -> Ease of Use

       -> Externalizable



    4.2 HTTP methods, Headers and Statuses

        -> HTTP Methods : Методите, които са наложени от HTTP (GET,POST,PUT,DELETE), много добре съвпдат семантично с CRUD операциите, които могат да бъдат изпълнявани върху даден ресурс.
                          GET методът не трябва да променя състоянието на ресурс
                          POST трябва да се използва за съдаването на нов ресурс в дадена колекция

        -> HTTP Status Codes : При възникване на грешка е добре да се върне в бодито на отговора json обект с подробни детайли за грешката както за клиента, така и за прогримста (конкретен ексепшън например). Може да се следва
                               формата за грешка предоставен от paypal guidelines. При грешка тип 5хх не трябва например да се дава stacktrace, защото по този начин ще дадем детайли за вътрешна имплементация на сървиси. По скоро
                               трябва да разчитаме на вътрешно създадени логове (да знаем откъде е минал потребителя, за да създаде конкретната грешка).
                                Препоръчва се да сведем използването на статус кодове за отговор до следния списък: 
                                200 (ОК), 201 (Created), 202 (Accepted), 204(No Content), 400(Bad Request), 401(Unauthorized),403,404,405,406,415,422,429,500,503

                                Как се свързват HTTP методите и съответните отговри може да се види в тази таблица : https://github.com/paypal/api-standards/blob/master/api-style-guide.md#http-method-to-status-code-mapping


   4.3 Hypermedia 

       Тук става въпрос за разнообразния вид на ресурсите : графичен, аудио, видео, обикновен текст, хипервръзки.

       Оттук идва и идеята за HATEOAS (Hypermedia As The Engine Of Application State) : Това е начин по, който може да се имплементира архитектурата на едно REST приложение. Основната идея е в отговорите, които връща сървиса да 
       се съдържат хипервръзки към останлите услуги на АПИ-то свързани с конкретния ресурс. Тоест сървиса казва на консуматора оттук нататък на къде може да се"движи". Подобно на един краен автомат със състояния, при който бъдейки в едно
       състояние можем да преминем в n на брой други.

       Едно АПИ, което се съобразява с HATEOAS концепцията предлага услугата като краен автомат от състояния. HTTP заявки с методите DELETE, POST, PUT, PATCH всъщност инициират прехода от едно състояние на крайния автомат в друго,
       а отговорът, който се връща от АПИ-то представлява новото състояние.

       Пример за HATEOAS : https://github.com/paypal/api-standards/blob/master/api-style-guide.md#hypermedia-compliant-api

       Link Description Object : Предсталяват JSON обект, който сам по себе си се явява едно състояние от споеманатия по-горе краен автомат. Property-тата на един такъв обект са:
 
                                       -> href : url-a не ресурса
                                       -> rel : The value of the rel property indicates the name of the relation to the target resource.
                                       -> method : The method property identifies the HTTP verb that MUST be used to make a request to the target of the link. The method property assumes a default value of GET if it is ommitted.
                                       -> title  : The title property provides a title for the link and is a helpful documentation tool to facilitate understanding by the end clients. This property is NOT REQUIRED.

       Link Array : Масив от Link Description обекти, всъщност е съвкупност от следващите състояния, към които може да се премине. 


    
   4.4 Naming Conventions

               https://example.com:8042/over/there?name=ferret#nose
               \___/   \_______________/\_________/\_________/\__/
                 |           |            |            |        |
              scheme     authority       path        query   fragment

   
       * Literals/expressions in URI paths SHOULD be separated using a hyphen ( - ).

       * Literals/expressions in query strings SHOULD be separated using underscore ( _ )

       * Plural nouns SHOULD be used in the URI where appropriate to identify collections of data resources. Example:   /invoices

       * An individual resource in a collection of resources MAY exist directly beneath the collection URI. Example :  /invoices/{invoice_id}

       * Sub-resource collections MAY exist directly beneath an individual resource. This should convey a relationship to another collection of resources (invoice-items, in this example). Example :  /invoices/{invoice_id}/items

       * URI paths and query strings MUST percent encode data into UTF-8 octets.

       * Sub-resource individual resources MAY exist, but should be avoided in favor of top-level resources
                       Example : /invoices/{invoice_id}/items/{item_id}
                       Better : /invoice-items/{invoice_item_id}

     4.4.1 Имената на ресурси : Трябва да бъдат съществителни, с малки букви и когато името на ресурс е съставено от няколко думи да се отделят с тире (-)

     4.4.2 Имената на параметрите на заявката : Литералите/изразите в един query string е добре да се разделят с (_) : ...?/event=passed_event
             
           Стойностите на параметрите на завката трябва да бъдат percent encoded, ако съдържат специални символи. Наоример space (' ') се кодира с %20
	   
       
    4.5 Състав на едно URI

        Обикновено включва главната версия на АПИ-то, следвана от namespace, имена на ресурс и опционално един или няколко под-ресура.

        https://api.foo.com/v1/vault/credit-cards/CARD-7LT50814996943336KESEVWA

        Namespace-овете се използват, за да придадат контекст и обхват на даден ресурс.

        От горния пример credit-cards е името на ресура, който преставлява колекция и затова е в мн.ч. Може да се използват query params, за да се укаже критерй за търсене в колекция.

        Един ресурс може да има подресурси и ако искаме да стигнем до тях трябва да предоставим името на подресура. Самият под-ресурс може да има връзка 1:1  с ресурса, което означава, че не необходима някаква допълнителна информация.

  
       4.5.1 Идентификатори на ресурси : 

             Добре е да се използват UUID (такива, които са уникални не само за таблицата, но и за цялата база)
   
             С оглед на сигурност и интегритет на данните, когато достъпваме под-ресурси по ид, е добре да го правим в обхвата на parent рeсурса.
                 Пример : /users/1234/linked-accounts/ABCD
                          Дори и account ABCD да съществува самостоятелно, не трябва да бъде достъпван освен ако не е в обхвата на потребител 1234.

             Не трябва да има два идентификатора на ресурс веднага един след друг : https://api.foo.com/v1/payments/payments/12345/102030

             Ид-тата на ресурсите трябва да използват ASCII символи, а не UTF-8.
             Ако ид-тата съдържат специални символи трябва да се използва perecent encoding.


       4.5.2 Параметри на заявките

             Параметри на заявката представляват двойка от име и стойност, които се изпозлват като критерии за търсене, чрез които се филтрира върнатата от апи-то колекция.

             Идентификатори на ресурсите не трябва да се използват като параметри на заявката, те трябва да се част от URI-то.
          
             Параметрите предназначени за странциране трябва да са съобразени спрямо гaйдлайни (https://github.com/paypal/api-standards/blob/master/patterns.md#pagination)

             Когато реферираме към конретен ресурс (/v1/payments/billing-plans/P-94458432VR012762KRWBZEUA) параметри не трябва да бъдат използвани.

             Когато използваме POST не се препоръчва да слага query параметри, по-добре е те да са дадени в request body-то.          

             Има ситуации, в които се налага подаването на двe различни стойности за един и същи параметър на заявката. Например, ако ресурсът има няколко различни състояния, като OPEN, CLOSED, INVALID. Ако консуматора иска всички ресурси, които са в 
             състояния CLOSED и INVALID ? Имда два подхода:
                          -> Препоръчителният подход е просто да се повтори два пъти параметъра на заявката обаче с различна стойност. Пример : ..../...?status=CLOSED&status=INVALID . Това е вариант, който се поткрепя от HTTP стандартите и е имплементиран
                             в повечето библиотеки за HTTP парсване. Самият параметър трябва да бъде маркиран като "repeatable":true в спецификацията на API-то. Името на параметъра трябва да бъде в единствено число.

                           -> Другият вариант не напълно приет от HTTP стандартизациите, може да се използва, когато URL става много дълъг и наближава границата от 2000 символа. Същността на подхода е името на параметъра да бъде в мн.ч. и след занка = стойностите
                              да са разделени със запетая. Тук обаче трябва да се отбележи, че от страна ана апи-то ще се наложи допълнително парсване на подадените параметри защото ще пристигнат като низ.
                              Пример: .../...?statuses=CLOSED,OPEN



    
       * JSON SCHEMA - начин за описание и валидиране на формата на HTTP заявките/отговорите, които са в JSON формат.




   *** Има още за четене от съветите на paypal


  

      4.6 OpenAPI Specification (OAS)

          Това е спецификация, която се използва за описание на REST API-тата. След като сме създали нашето апи тази спецификация ни нужна, за да улесним неговото използване от други консумтоари - било то други апи-та (machine-to-machine) или 
          хора, които ще четат спецификацията в четим за човека формат. OpenAPI спецификацията не е обвързана с конкретен език или "софтуерент гигант". Превърнала се в стандарт за индустрията.
         
          OpenApi документът е в текстов формат, обикновено с имената : openapi.json, openapi.yml, представлявайки JSON обект изразен в YML или JSON формат. Всъщност тъй като JSON е подмножество на YML може да комбинираме двата синтаксиса,
          което не е много препоръчително, но е възможно в специфични ситуации. 

          Минималната структура на документа включва следните полета: 

                                          -> openapi : низ представляващ версията на OpenAPI, която се използва
                                          -> info : предоставя обща информация за описваното API. Като съдържа подполетата: title, description, termsOfService, contact, license, verion. Елементите title и version са само задължителни
                                          -> paths, components, webhooks (само едно от тези полета е задължително)
    


          Пример за минимална структура на един openapi файл : 


           openapi: 3.1.0
           info:
             title: A minimal OpenAPI document
             version: 0.0.1
           paths: {} # No endpoints defined

           Тhis API is not very useful because it defines no operations (it has no endpoints). The next page remedies that.


           Сега нека рагледаме полето paths : Чрез всяко подполе на paths всъщност се описват точките за достъп (endpoints), които се предлагат от нашето API във вид на Path Item Objects.
           Един Path Item Object описва HTTP методите, които може да се прилагат на дадения path с конкретните http имена (get, post, delete, put). За всяко поле с име на HTTP метод пък
           има прикачен Operation Object,  който съдържа описание на услугата(summary, description) и нови два обект Responses и Parameters.
           Response обектът задължително съдържа поле description, в което се описва значение на отговра в контекста на приложението. Важно поле на Response обекта е content, защото описва типа на
           съдържанието на отговора.

           Примeрeн openapi файл може да бъде намерен на  : https://oai.github.io/Documentation/examples/tictactoe.yaml


            JSON schema's primary purpose is not to specify APIs. OpenAPI is tailor-made for that. It uses JSON Schemas internally as part of its data structure. If your aim is to generate Java from an API spec,
            choose OpenAPI (assuming your API is REST or at least REST-ish).


        4.7 JSON-B

            За дълъг период от време не e имало наложен стандарт (JSR) за това как да се преобразуват Java обекти в JSON и обратното. Въпреки това са се обособили две масово изпозлвани java библиотеки, които са насочени върху тази задача.
            Това са Jackson и Gson.

            С появата на JEE 8 се създава и такъв стандарт - JSR367 (Java API for JSON Binding). Библиотеките, които напълно имплементират този стандарт са Eclipse Yasson(това е RI имплемнтацията) и Apache Johnzon.

            Важно е да се спомене, че Jackson не имплементира JSR367. 


        4.8 Jackson 

            Предоставя лесен начин за преобразуване на Java обекти в JSON и обратното. Съдържа се в Spring Boot parent pom-a и версията се управлява оттам. При спринг буут проектите е необходимо само добавянето на jackson package
            в пом-а и ако даден контролер е анотиран с @RestController ще се осъществява автоматично преобразуване на  аргументите и върнатите обекти на контролер методите от POJO в JSON и обратно.


        4.9 Spring Docs, Swagger, Spring Fox

            Първо нека да започнем с разясняване на разликата между OpenAPI и Swagger. OpenAPI е спецификация за описание на дадено API независмо от програмния език, чрез който апи-то е имплементирано.
            Като говорим за Swagger имаме предвид набор от инстументи, чрез които се имплементира OpenAPI стандарта за описание на нашето API. Компоненти на Swagger са : Swagger UI (използва се за генераиране на уеб страници от 
            OpenAPI документ, описвсащ самото апи), Swagger Editor (позволява редактирането на OpenAPI документи вътре в самия browser), Swagger Codegen (използват се за автоматично генераране на клиенти за даденото API),
            Swagger Core (съдържа свързани с Java библиотеки, които се изпозлват за създаване, консумиране и работа с OpenAPI дефиниции), Swagger Parser, Swagger Inspector, SwaggerHub.

            Интеграцията на spring-boot и swagger-ui става единствено с добавянето на [springdoc-openapi-ui] dependecy. Самата уеб страница съдържаща описанието на нашето апи се достъпва през :http://server:port/context-path/swagger-ui.html
     
            Kъм този момент (02.2022) springdoc-openapi-ui е заместител на по-стария вариант springfox.

            Конфигурарирането на документацията става посредством анотации. Практиката е да се направи един отделен конфигурационен клас, който да се анотра с @OpenAPIDefinition @Configuration @SecurityScheme
            
            За да се генерира правилно документация за error handling класовете (тези анотирани с @ControllerAdvice), трябва методите на въпросния контролер адвайс да са анотирани с @ResponseStatus.

            Документиране на приложение използващо SpringMVC (https://springdoc.org/#spring-webmvc-support) -> This dependency is relevant if you want to generate the OpenAPI description without using the swagger-ui.


         4.10 JAX-RS vs Spring MVC (https://www.baeldung.com/rest-api-jax-rs-vs-spring)

              To become part of the JAVA EE world, a feature must have a specification, a compatible implementation, and a TCK. 
              Спецификациите от една страна са хубаво нещо, защото задават основните посоки, а вече имплементаторите се занимават с конкретната имплементация. От гледна точка на програмиста е добре да пише код използвайки
              класове от javax/jakarta пакетите (т.е спецификацията). Така по всяко време лесно може да минава от един имплементатор на спецификация към друг.

              JAX-RS е спецификация част от Java EE спецификацията (A specification doesn't contain anything. It's a piece of paper.). В тази спецификация се дават насоки как да пишем Java приложения в "духа" на REST архитектурата.
              Reference имплементациите на JAX-RS са RESTEasy и Jersey.
             
              Spring MVC е модул от Spring Framework предназначен за създаване на уеб приложения, добавяйки възможност за разработка на приложения насочени към REST архитектурата. Използвайки класовете от web mvc модула всъщност
              правим нашето приложение зависимо от екосистемата на Spring, a не от Java Enterprise спецификациите. Разбира се бъдейки част от Spring може да се възползваме от DI.


         4.11 Spring RestTemplate

              RestTemplate е клас предоставян от Spring, който представлява HTTP клиент. Всъщност на ниско ниво използва клиентска библиотека предлагана от JDK HttpURLConnection (по-подразбиране), Apache HttpClient и други.
	      Може да се ползва като консуматор на създадени от нас REST услуги и да се пишат инеграционни тестове (да се уверим дали API-то се държи както предполагаме).
              
              Характерното за RestTempalte е, че използва една нишка за всяка заявка и всяка заявка направена през RestTemplate обекта блокира тази нишка докато не се върне отоговор (т.е не може да се изпълнява друг код докато нямаме
              отговор от API-то).

              !!! Към (02.2022) официалната документация на Spring препоръчва използването на WebClient на мястото на RestTemplate, тъй като планира за вбъдеще да напрви RestTemplate deprecated.
             
              RestTemplate предлага методи кореспондиращи с HTTP методите. По-долу е даден списък с някои от тях : 

                                         -> getForEntity() : Изпълнява GET за даден ресурс и връща обект от клас ResponseEnity, в който се съдържа както HTTP  кода за отговор, така и върнатия ресурс.

                                         -> getForObject() : Връща директно ресурс, който е извлечен, но не и response кода

                                         -> exchange() : Този метод е общ и приема като параметър URI на ресурса, HTTP метода и др. Като отговор връща ResponseEntity (върнатият ресурс във вид на обект и статуса на отговора)

                                         -> execute() : Подобен на exchenge(), но приема и аргуемнти : RequestCallback  и ResultSetExtractor

                                         -> delete()
                                         -> put()
                                         -> postForObject()
                                         -> postForLocation()

         4.12 Spring WebClient

             Въпросният клас представялва REST клиент (като разгледания вече RestTemplate), като основната разлика е, че при него изивкванията, представляващи HTTP заявки,не блокират текущата нишка
             и може да се пише в rective стил. Всъщност класът се появаява заедно с WebFlux идеологията на Spring. С WebClient все още могат да се правят и блокиращи извиквания, т.е поддържа
             се синхрoнност и асинхронност при извикванията.

             По-долу е даден пример за едно блокиращо извкване, като резултатът се съхранява в ResponseEntity клас, който капсулира както бодито на заявката, така и статус кода.

              ResponseEntity<GameSessionInfo> retrievedGameResponse =
                 webClient
                    .get()
                    .uri("http://localhost:8080/hangman-game/api/v1/games/" + gameId)
                    .accept(MediaTypes.HAL_JSON)
                    .retrieve()
                    .toEntity(GameSessionInfo.class)
                    .block();

               
             Горният пример адресира ситуацията, в която API-то  ни връща в респонс бодито обикновен JSON обект и той директно може да се парсне към съответния клас чрез Jackson.

             Какво става обаче, ако комуникираме с API, което връща отговори в стил HATEOS ? Трябва да направим така, че WebClient-а да може да разбира hypermedia отговори. Затова се 
             налага да добавим един нов бийн чрез конфигурационен клас (клас, който е анотиран с @Configuragation и има следния factory метод) : 

             @Bean 
             WebClientCustomizer hypermediaWebClientCustomizer(HypermediaWebClientConfigurer configurer) { 
                   return webClientBuilder -> { 
                        configurer.registerHypermediaTypes(webClientBuilder); 
                   };
              }

           След това трябва да инжектираме, където ни трябва (например в тест класа) следния бийн : @Autowired WebClient.Builder webClientBuilder и когато ни потрябва инстанция на WebClient да
           направим просто : WebClient webClient =  webClientBuilder.build();


            Нека обърнем внимание и на още една потенциална ситуация : API-то връща цяла колекция чрез Spring HATEOAS обект от клас CollectionModel<GameSessionInfo>, тогава ако
            подходим по горния начин ще трябва да имаме обект от клас ResponseEntity<CollectionModel<GameSessionInfo>> , в който да запишем отговора от АПИ-то. Проблемът обаче идва,
            когато трябва да подадем параметър на toEntity метода и този параметър трябва да изглежда така : CollectionModel<GameSessionInfo>.class . Това обаче не валидно в Java. Tук
            на помощ ни идва ParameterizedTypeReference и примерна заявка с WebClient би изглеждала по следния начин  :

            webClient
            .get()
            .uri("http://localhost:8080/hangman-game/api/v1/games/ongoing")
            .accept(MediaTypes.HAL_JSON)
            .retrieve()
            .toEntity(new ParameterizedTypeReference<CollectionModel<GameSessionInfo>>() {})
            .block();


